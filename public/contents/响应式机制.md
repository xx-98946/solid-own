# 响应式机制

信号量的英文原称为`Signals`，是最近在前端框架领域越来越广泛使用的机制之一，其功能是实现状态和视图的同步，这通常也被叫做`MVVM`。

## MVVM 的重要性

为什么要使用`MVVM`呢，单纯使用命令式进行开发会存在问题么？答案是肯定的，对于任意一个前端工程，只要超出`TodoMVC`的复杂度，就有必要引入`MVVM`。

### 基本概念

- M：Model 模型，模型就是一套结构化数据
- V：View 视图，视图就是DOM结构
- VM: View Model 视图模型，用于对模型和视图进行同步

对于通用的前端项目，比如后台管理系统或者其他，暂时不考虑2D或者3D图表的问题，项目中最大的复杂度在于`模型`和`视图`的对应关系。

### 视图和模型的问题

1. 模型数据更改时，需要同步视图展示，视图要展示最新的数据
2. 视图执行DOM操作时，要将操作结果更新到模型数据上

显然两者都会触发非常多的事件，而每一个事件的处理都要让两者保持同步，这显然是非常复杂的。

### 视图模型

为了解决这个问题，则引入了`视图模型`，`视图模型`在其中的作用就是同步两者，让我们从数学上通过类比来理解这个问题。

存在一个一一映射函数，简单理解就是<span class="font-semibold">\` y=f(x) \`</span>,该函数也存在反函数<span class="font-semibold">\` x=f<sup>-1</sup>(y) \`</span>。假设`x`和`y`的对应关系是`(1,1),(2,4),(3,9)...`，如果我们能发现法则是平方函数，我们就可以轻松的从`x`推导出`y`，或者反过来。其中规则`f`就是所谓的`VM`，而`x`和`y`则是`模型`和`视图`。

视图和模型并不像上述的数学示例所述的简单结构，都是树和图结构，所以真实情况会更复杂一些，但是原理是相同的。

同时视图模型还需要处理一些副作用，如打印日志，发送请求到服务器等，

## 视图模型的实现机制

那视图模型该如何实现呢？视图模型需要完成以下两种功能，让我们逐步深入：

1. 视图事件同步到数据模型
2. 数据模型修改时同步到视图

- 第一项功能浏览器已经实现了，就是事件监听功能，通过事件的触发可以操作模型。
- 第二项功能则比较复杂，需要将数据模型同步到视图上。

现在让我们从一个简单案例开始吧，这段代码是最原始的`html + js`实现的。

### 步骤一 原始实现

```html
<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>信号量测试1</title>
    </head>
    <body>
        <!-- 定义HTML结构 -->
        <div>
            <div>
                <span>姓:</span>
                <input id="firstName" placeholder="请输入姓" />
            </div>
            <div>
                <span>名:</span>
                <input id="lastName" placeholder="请输入名" />
            </div>
            <div>
                <span>姓名: </span>
                <span id="fullName"></span>
            </div>
        </div>

        <!-- 操作脚本 -->
        <script>
            const firstName = document.getElementById("firstName");
            const lastName = document.getElementById("lastName");
            const fullName = document.getElementById("fullName");

            const data = {
                firstName: "",
                lastName: "",
                fullName: "",
            };

            /**
             * 更新 fullName 数据
             * 同时将数据更新到模版上
             */
            function updateFullName() {
                data.fullName = data.firstName + data.lastName;
                fullName.innerText = data.fullName;
            }

            firstName.addEventListener("input", (e) => {
                data.firstName = e.target.value;
                // 触发更新
                updateFullName();
            });

            lastName.addEventListener("input", (e) => {
                data.lastName = e.target.value;
                // 触发更新
                updateFullName();
            });
        </script>
    </body>
</html>
```

以下是功能展示，功能就是拼接用户输入的姓和名并显示到视图的姓名字段。

<iframe src="/signal-test1.html" class="shadow-lg border border-gray-200 w-full h-24" ></iframe>

### 步骤二 保持同步

那上述代码存在什么问题呢？如果我们在脚本中执行`data.firstName = "姓"`，页面上的姓和姓名两个字段的内容都是不能显示你的姓的，那如何才能让它按照我们设想中的那样执行呢？这就要使用`Proxy`这个对象了，该对象可以让监听到对象属性的变化。

```html
<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>信号量测试2</title>
    </head>
    <body>
        <div>
            <div>
                <span>姓:</span>
                <input id="firstName" placeholder="请输入姓" />
            </div>
            <div>
                <span>名:</span>
                <input id="lastName" placeholder="请输入名" />
            </div>
            <div>
                <span>姓名: </span>
                <span id="fullName"></span>
            </div>
        </div>

        <script>
            const firstName = document.getElementById("firstName");
            const lastName = document.getElementById("lastName");
            const fullName = document.getElementById("fullName");

            const data = new Proxy(
                {
                    firstName: "",
                    lastName: "",
                    fullName: "",
                },
                {
                    /**
                     * 在执行赋值操作时会触发该函数
                     */
                    set(obj, prop, newValue) {
                        // 将新值赋值给原始对象
                        obj[prop] = newValue;
                        // 并对不同的属性触发不同的操作
                        if (prop == "firstName") {
                            firstName.value = data.firstName;
                            updateFullName();
                        } else if (prop == "lastName") {
                            lastName.value = data.lastName;
                            updateFullName();
                        } else if (prop == "fullName") {
                            fullName.innerText = data.fullName;
                        }
                    },
                },
            );

            function updateFullName() {
                data.fullName = data.firstName + data.lastName;
                // 将更新的操作移动到了 set 函数内
            }

            firstName.addEventListener("input", (e) => {
                data.firstName = e.target.value;
            });

            lastName.addEventListener("input", (e) => {
                data.lastName = e.target.value;
            });

            // 测试同步效果
            data.firstName = "姓";
            data.lastName = "名";

            console.log(data);
        </script>
    </body>
</html>
```

以下是功能展示，此时三个变量都已经正确同步了，在修改变量时也可以保持同步状态，这非常好。

<iframe src="/signal-test2.html" class="shadow-lg border border-gray-200 w-full h-24" ></iframe>

让我们观察这个`set`函数，我们在定义函数时就需要知道要同步哪些数据到哪部分的视图中去。实际上，应用中的数据和视图都是非常多的，这个函数实现将变得非常繁琐，而且很容易出错。

让我们先梳理一下上述的过程，将每个过程都拆分的细致一些：

1. 修改`firstName`时, 要执行两种操作
    - 将`firstName`更新到视图中
    - 重新计算`fullName`
2. 修改`lastName`时, , 要执行两种操作
    - 将`lastName`更新到视图中
    - 重新计算`fullName`
3. 修改`fullName`时, 只要执行一种动作
    - 将`fullName`更新到视图中

### 步骤三 发布订阅

将操作直接写入`set`函数中灵活性太差了，要解决这个问题，可以使用发布订阅模式，每次调用`set`方法就表示发布，发布时会触发所有订阅，订阅可以随时解除或者新增，下面是一个简单实现。

```html
<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>信号量测试3</title>
    </head>
    <body>
        <div>
            <div>
                <span>姓:</span>
                <input id="firstName" placeholder="请输入姓" />
            </div>
            <div>
                <span>名:</span>
                <input id="lastName" placeholder="请输入名" />
            </div>
            <div>
                <span>姓名: </span>
                <span id="fullName"></span>
            </div>
        </div>

        <script>
            const firstName = document.getElementById("firstName");
            const lastName = document.getElementById("lastName");
            const fullName = document.getElementById("fullName");

            const data = new Proxy(
                {
                    firstName: "",
                    lastName: "",
                    fullName: "",
                },
                {
                    set(obj, prop, newValue) {
                        const oldValue = obj[prop];
                        obj[prop] = newValue;
                        /**
                         * 通过发布订阅模式触发对应的事件
                         */
                        dataEvents.update(prop, newValue, oldValue);
                    },
                },
            );

            /**
             * 发布订阅器
             * 核心就是为每个属性维护了一个函数执行数组
             * 这样就可以通过 push 操作添加订阅
             */
            const dataEvents = {
                update(prop, newValue, oldValue) {
                    dataEvents[prop].forEach((cb) => {
                        cb(newValue, oldValue);
                    });
                },
                firstName: [],
                lastName: [],
                fullName: [],
            };

            /**
             * 添加函数订阅，对于每个属性都可以单独订阅
             */
            dataEvents.firstName.push(function (newValue) {
                firstName.value = newValue;
            });

            dataEvents.firstName.push(function (newValue) {
                data.fullName = data.firstName + data.lastName;
            });

            dataEvents.lastName.push(function (newValue) {
                lastName.value = newValue;
            });

            dataEvents.lastName.push(function (newValue) {
                data.fullName = data.firstName + data.lastName;
            });

            dataEvents.fullName.push(function (newValue) {
                fullName.innerText = newValue;
            });

            firstName.addEventListener("input", (e) => {
                data.firstName = e.target.value;
            });

            lastName.addEventListener("input", (e) => {
                data.lastName = e.target.value;
            });

            data.firstName = "姓";
            data.lastName = "名";

            // 这段代码可以先注释掉，通过在控制套粘贴也是可以被触发的
            dataEvents.fullName.push(function (newValue, oldValue) {
                console.log(`将 fullName 从 ${oldValue} 变更为 ${newValue}`);
            });

            console.log(dataEvents);
        </script>
    </body>
</html>
```

以下是功能展示，此时可以在数据定义之外添加新的订阅了，我们离目标又近了一步。

<iframe src="/signal-test3.html" class="shadow-lg border border-gray-200 w-full h-24" ></iframe>

### 步骤四 订阅整合

从上一个示例中我们发现，`firstName` 和 `lastName` 都会触发`fullName`的修改，这被称作派生或者计算变量。而在真实的场景中，派生变量可能会依赖更多的变量，让我们把这种计算过程整合到一起吧。也就是编写一个`watch`函数，函数参数分别是要触发的函数以及需要监听的属性列表。

```html
<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>信号量测试4</title>
    </head>
    <body>
        <div>
            <div>
                <span>姓:</span>
                <input id="firstName" placeholder="请输入姓" />
            </div>
            <div>
                <span>名:</span>
                <input id="lastName" placeholder="请输入名" />
            </div>
            <div>
                <span>姓名: </span>
                <span id="fullName"></span>
            </div>
        </div>

        <script>
            const firstName = document.getElementById("firstName");
            const lastName = document.getElementById("lastName");
            const fullName = document.getElementById("fullName");

            const data = new Proxy(
                {
                    firstName: "",
                    lastName: "",
                    fullName: "",
                },
                {
                    set(obj, prop, newValue) {
                        obj[prop] = newValue;
                        dataEvents.update(prop);
                    },
                },
            );

            const dataEvents = {
                update(prop, newValue, oldValue) {
                    dataEvents[prop].forEach((cb) => {
                        cb();
                    });
                },
                firstName: [],
                lastName: [],
                fullName: [],
            };

            /**
             * 定义监听函数
             */
            function watch(cb, propers) {
                propers.forEach((prop) => {
                    dataEvents[prop].push(cb);
                });
            }

            watch(
                function (newValue) {
                    firstName.value = data.firstName;
                },
                ["firstName"],
            );

            watch(
                function () {
                    data.fullName = data.firstName + data.lastName;
                },
                ["firstName", "lastName"],
            );

            watch(
                function () {
                    lastName.value = data.lastName;
                },
                ["lastName"],
            );

            watch(
                function () {
                    fullName.innerText = data.fullName;
                },
                ["fullName"],
            );

            firstName.addEventListener("input", (e) => {
                data.firstName = e.target.value;
            });

            lastName.addEventListener("input", (e) => {
                data.lastName = e.target.value;
            });

            data.firstName = "姓";
            data.lastName = "名";

            console.log(dataEvents);
        </script>
    </body>
</html>
```

以下是功能展示，显然重构后代码逻辑更加一致了，而且保持了原有页面功能。

<iframe src="/signal-test4.html" class="shadow-lg border border-gray-200 w-full h-24" ></iframe>

### 步骤五 依赖收集

我们离成功只有一步之遥了，但此时会碰到一个困扰了我很久的难题-`依赖收集`。所谓依赖收集，就是去除掉`watch`的第二个函数参数，从函数实现中我们可以观察到，第二个函数参数数组实际上是冗余的，`哪个属性变化会触发函数`已经包含实现中了。这个问题为什么困难呢？

1. 访问属性时怎么触发事件呢？`Proxy`的`get`方法可以自动触发
2. `get`触发时，怎么获取到要执行的函数以进行订阅呢？答案是使用全局变量

```html
<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>信号量测试4</title>
    </head>
    <body>
        <div>
            <div>
                <span>姓:</span>
                <input id="firstName" placeholder="请输入姓" />
            </div>
            <div>
                <span>名:</span>
                <input id="lastName" placeholder="请输入名" />
            </div>
            <div>
                <span>姓名: </span>
                <span id="fullName"></span>
            </div>
        </div>

        <script>
            const firstName = document.getElementById("firstName");
            const lastName = document.getElementById("lastName");
            const fullName = document.getElementById("fullName");

            /**
             * 定义全局监听变量，每次调用watch时修改改属性
             * 同时该变量会在`get`时被绑定
             */
            let currentSubcribe = null;

            const data = new Proxy(
                {
                    firstName: "",
                    lastName: "",
                    fullName: "",
                },
                {
                    /**
                     * 添加获取监听
                     */
                    get(obj, prop) {
                        if (currentSubcribe) {
                            dataEvents[prop].push(currentSubcribe);
                        }
                        return obj[prop];
                    },
                    set(obj, prop, newValue) {
                        obj[prop] = newValue;
                        dataEvents.update(prop);
                    },
                },
            );

            const dataEvents = {
                update(prop, newValue, oldValue) {
                    dataEvents[prop].forEach((cb) => {
                        cb();
                    });
                },
                firstName: [],
                lastName: [],
                fullName: [],
            };

            /**
             * 定义监听函数
             */
            function watch(cb) {
                currentSubcribe = cb;
                cb();
                currentSubcribe = null;
            }

            watch(function (newValue) {
                firstName.value = data.firstName;
            });

            watch(function () {
                data.fullName = data.firstName + data.lastName;
            });

            watch(function () {
                lastName.value = data.lastName;
            });

            watch(function () {
                fullName.innerText = data.fullName;
            });

            firstName.addEventListener("input", (e) => {
                data.firstName = e.target.value;
            });

            lastName.addEventListener("input", (e) => {
                data.lastName = e.target.value;
            });

            data.firstName = "姓";
            data.lastName = "名";

            console.log(dataEvents);
        </script>
    </body>
</html>
```

以下是功能展示，这就是视图模型的全部功能了。

<iframe src="/signal-test4.html" class="shadow-lg border border-gray-200 w-full h-24" ></iframe>

视图模型的核心功能就是响应式机制，到这里我们就讲解结束了。当然这里只是最简化的一个版本，还有很多问题需要解决，但这些就需要精细的打磨了。

- 如对于普通变量或者深层嵌套变量如何处理？
- 如何将`jsx`或者`template`如何处理为渲染函数？
